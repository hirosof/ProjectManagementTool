# DB設計書

**作成日**: 2026-01-16
**対象**: プロジェクト管理ツール
**DB**: SQLite
**前提**: `1_プロジェクト管理ツール_ClaudeCode仕様書.md` および `3_プロジェクト管理ツール_実装方針確定メモ.md`

---

## 1. 概要

本ドキュメントは、プロジェクト管理ツールのデータベース設計を定義する。

### 設計方針
- SQLite標準の機能のみを使用
- 外部キー制約を有効化（`PRAGMA foreign_keys = ON`）
- トランザクションによる整合性保証
- 将来の拡張性を考慮（SubProjectの入れ子対応など）

---

## 2. テーブル一覧

| テーブル名 | 説明 |
|-----------|------|
| `projects` | プロジェクト |
| `subprojects` | サブプロジェクト（フォルダ相当） |
| `tasks` | タスク |
| `subtasks` | サブタスク |
| `task_dependencies` | タスク間依存関係 |
| `subtask_dependencies` | サブタスク間依存関係 |
| `templates` | テンプレート定義 |
| `template_nodes` | テンプレート内のノード情報 |
| `schema_version` | スキーマバージョン管理 |

---

## 3. テーブル定義

### 3.1 projects

**説明**: プロジェクトを管理するテーブル

```sql
CREATE TABLE projects (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    order_index INTEGER NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX idx_projects_order ON projects(order_index);
```

**カラム説明**:
- `id`: プロジェクトID（主キー）
- `name`: プロジェクト名（全体でユニーク）
- `description`: プロジェクトの説明（任意）
- `order_index`: 表示順（整数、手動制御）
- `created_at`: 作成日時
- `updated_at`: 更新日時

**制約**:
- `name`は全体でユニーク
- `order_index`は表示順制御用（同一階層内で管理）

---

### 3.2 subprojects

**説明**: サブプロジェクト（フォルダ相当）を管理するテーブル

```sql
CREATE TABLE subprojects (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id INTEGER NOT NULL,
    parent_subproject_id INTEGER DEFAULT NULL,
    name TEXT NOT NULL,
    description TEXT,
    order_index INTEGER NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_subproject_id) REFERENCES subprojects(id) ON DELETE CASCADE,
    UNIQUE(project_id, parent_subproject_id, name)
);

CREATE INDEX idx_subprojects_project ON subprojects(project_id);
CREATE INDEX idx_subprojects_parent ON subprojects(parent_subproject_id);
CREATE INDEX idx_subprojects_order ON subprojects(project_id, parent_subproject_id, order_index);
```

**カラム説明**:
- `id`: サブプロジェクトID（主キー）
- `project_id`: 所属するプロジェクトID
- `parent_subproject_id`: 親サブプロジェクトID（NULL = Project直下、将来の入れ子対応用）
- `name`: サブプロジェクト名
- `description`: 説明（任意）
- `order_index`: 表示順（同一親配下でユニーク性は不要）
- `created_at`: 作成日時
- `updated_at`: 更新日時

**制約**:
- `project_id + parent_subproject_id + name`の組み合わせでユニーク
- MVP実装では`parent_subproject_id`は常にNULL（1階層のみ）
- 将来の入れ子拡張に備えたカラム設計

---

### 3.3 tasks

**説明**: タスクを管理するテーブル

```sql
CREATE TABLE tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id INTEGER NOT NULL,
    subproject_id INTEGER DEFAULT NULL,
    name TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL DEFAULT 'UNSET',
    order_index INTEGER NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
    FOREIGN KEY (subproject_id) REFERENCES subprojects(id) ON DELETE CASCADE,
    UNIQUE(project_id, subproject_id, name),
    CHECK(status IN ('UNSET', 'NOT_STARTED', 'IN_PROGRESS', 'DONE'))
);

CREATE INDEX idx_tasks_project ON tasks(project_id);
CREATE INDEX idx_tasks_subproject ON tasks(subproject_id);
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_order ON tasks(project_id, subproject_id, order_index);
```

**カラム説明**:
- `id`: タスクID（主キー）
- `project_id`: 所属するプロジェクトID
- `subproject_id`: 所属するサブプロジェクトID（NULL = Project直下）
- `name`: タスク名
- `description`: タスクの説明（任意）
- `status`: ステータス（UNSET, NOT_STARTED, IN_PROGRESS, DONE）
- `order_index`: 表示順
- `created_at`: 作成日時
- `updated_at`: 更新日時

**制約**:
- `project_id + subproject_id + name`の組み合わせでユニーク
- TaskはProject直下（subproject_id = NULL）またはSubProject配下のいずれか一箇所にのみ所属
- `status`はCHECK制約で定義された値のみ許可

---

### 3.4 subtasks

**説明**: サブタスクを管理するテーブル

```sql
CREATE TABLE subtasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL DEFAULT 'UNSET',
    order_index INTEGER NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
    UNIQUE(task_id, name),
    CHECK(status IN ('UNSET', 'NOT_STARTED', 'IN_PROGRESS', 'DONE'))
);

CREATE INDEX idx_subtasks_task ON subtasks(task_id);
CREATE INDEX idx_subtasks_status ON subtasks(status);
CREATE INDEX idx_subtasks_order ON subtasks(task_id, order_index);
```

**カラム説明**:
- `id`: サブタスクID（主キー）
- `task_id`: 所属するタスクID
- `name`: サブタスク名
- `description`: サブタスクの説明（任意）
- `status`: ステータス（UNSET, NOT_STARTED, IN_PROGRESS, DONE）
- `order_index`: 表示順（同一Task配下）
- `created_at`: 作成日時
- `updated_at`: 更新日時

**制約**:
- `task_id + name`の組み合わせでユニーク
- `status`はCHECK制約で定義された値のみ許可

---

### 3.5 task_dependencies

**説明**: タスク間の依存関係を管理するテーブル（Finish-to-Start）

```sql
CREATE TABLE task_dependencies (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    predecessor_id INTEGER NOT NULL,
    successor_id INTEGER NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (predecessor_id) REFERENCES tasks(id) ON DELETE CASCADE,
    FOREIGN KEY (successor_id) REFERENCES tasks(id) ON DELETE CASCADE,
    UNIQUE(predecessor_id, successor_id),
    CHECK(predecessor_id != successor_id)
);

CREATE INDEX idx_task_deps_predecessor ON task_dependencies(predecessor_id);
CREATE INDEX idx_task_deps_successor ON task_dependencies(successor_id);
```

**カラム説明**:
- `id`: 依存関係ID（主キー）
- `predecessor_id`: 先行タスクID
- `successor_id`: 後続タスクID
- `created_at`: 作成日時

**制約**:
- `predecessor_id + successor_id`の組み合わせでユニーク
- 自己参照禁止（CHECK制約）
- 同一Project内のTaskのみ依存可能（アプリケーション層でチェック）
- DAG制約（循環禁止）はアプリケーション層でチェック

**削除時の動作**:
- タスク削除時、依存関係も連鎖削除（CASCADE）
- アプリケーション層で橋渡し再接続処理を実装

---

### 3.6 subtask_dependencies

**説明**: サブタスク間の依存関係を管理するテーブル（Finish-to-Start）

```sql
CREATE TABLE subtask_dependencies (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    predecessor_id INTEGER NOT NULL,
    successor_id INTEGER NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (predecessor_id) REFERENCES subtasks(id) ON DELETE CASCADE,
    FOREIGN KEY (successor_id) REFERENCES subtasks(id) ON DELETE CASCADE,
    UNIQUE(predecessor_id, successor_id),
    CHECK(predecessor_id != successor_id)
);

CREATE INDEX idx_subtask_deps_predecessor ON subtask_dependencies(predecessor_id);
CREATE INDEX idx_subtask_deps_successor ON subtask_dependencies(successor_id);
```

**カラム説明**:
- `id`: 依存関係ID（主キー）
- `predecessor_id`: 先行サブタスクID
- `successor_id`: 後続サブタスクID
- `created_at`: 作成日時

**制約**:
- `predecessor_id + successor_id`の組み合わせでユニーク
- 自己参照禁止（CHECK制約）
- 同一Task内のSubTaskのみ依存可能（アプリケーション層でチェック）
- DAG制約（循環禁止）はアプリケーション層でチェック

**削除時の動作**:
- サブタスク削除時、依存関係も連鎖削除（CASCADE）
- アプリケーション層で橋渡し再接続処理を実装

---

### 3.7 templates

**説明**: テンプレート定義を管理するテーブル

```sql
CREATE TABLE templates (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    base_type TEXT NOT NULL,
    base_id INTEGER NOT NULL,
    include_tasks BOOLEAN NOT NULL DEFAULT 1,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    CHECK(base_type IN ('project', 'subproject', 'task'))
);

CREATE INDEX idx_templates_name ON templates(name);
```

**カラム説明**:
- `id`: テンプレートID（主キー）
- `name`: テンプレート名（全体でユニーク）
- `description`: テンプレートの説明（任意）
- `base_type`: 基点のノードタイプ（project, subproject, task）
- `base_id`: 基点のノードID（保存時点のID、参照整合性は不要）
- `include_tasks`: Task/SubTaskを含むか（1 = 含む, 0 = 構造のみ）
- `created_at`: 作成日時

**制約**:
- `name`は全体でユニーク
- `base_type`はCHECK制約で定義された値のみ許可

**注意**:
- `base_id`は保存時点のスナップショットであり、元ノードとの関連は持たない
- テンプレート適用時は全ノードに新IDを割り当てる（スナップショット方式）

---

### 3.8 template_nodes

**説明**: テンプレート内のノード情報を管理するテーブル

```sql
CREATE TABLE template_nodes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    template_id INTEGER NOT NULL,
    node_type TEXT NOT NULL,
    original_id INTEGER NOT NULL,
    parent_original_id INTEGER DEFAULT NULL,
    name TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL,
    order_index INTEGER NOT NULL,
    FOREIGN KEY (template_id) REFERENCES templates(id) ON DELETE CASCADE,
    CHECK(node_type IN ('project', 'subproject', 'task', 'subtask')),
    CHECK(status IN ('UNSET', 'NOT_STARTED', 'IN_PROGRESS', 'DONE'))
);

CREATE INDEX idx_template_nodes_template ON template_nodes(template_id);
CREATE INDEX idx_template_nodes_original ON template_nodes(template_id, original_id);
```

**カラム説明**:
- `id`: テンプレートノードID（主キー）
- `template_id`: 所属するテンプレートID
- `node_type`: ノードタイプ（project, subproject, task, subtask）
- `original_id`: 保存時点の元のノードID（テンプレート内での識別用）
- `parent_original_id`: 親ノードのoriginal_id（階層構造の保持）
- `name`: ノード名
- `description`: 説明
- `status`: ステータス（保存時点）
- `order_index`: 表示順

**テンプレート適用時の処理**:
1. `original_id`をキーに新IDをマッピング
2. 親子関係・依存関係を新IDで再構築
3. ステータスは適用時の選択（コピー/UNSET化/NOT_STARTED化）に従う

---

### 3.9 schema_version

**説明**: スキーマバージョン管理テーブル

```sql
CREATE TABLE schema_version (
    version INTEGER PRIMARY KEY,
    applied_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- 初期バージョンを挿入
INSERT INTO schema_version (version) VALUES (1);
```

**カラム説明**:
- `version`: スキーマバージョン（主キー）
- `applied_at`: 適用日時

**用途**:
- マイグレーション管理
- バージョン互換性チェック

---

## 4. 初期化SQL

### 4.1 データベース初期化スクリプト

```sql
-- 外部キー制約を有効化
PRAGMA foreign_keys = ON;

-- スキーマバージョンテーブル作成
CREATE TABLE schema_version (
    version INTEGER PRIMARY KEY,
    applied_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- 初期バージョン挿入
INSERT INTO schema_version (version) VALUES (1);

-- projects テーブル作成
CREATE TABLE projects (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    order_index INTEGER NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX idx_projects_order ON projects(order_index);

-- subprojects テーブル作成
CREATE TABLE subprojects (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id INTEGER NOT NULL,
    parent_subproject_id INTEGER DEFAULT NULL,
    name TEXT NOT NULL,
    description TEXT,
    order_index INTEGER NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_subproject_id) REFERENCES subprojects(id) ON DELETE CASCADE,
    UNIQUE(project_id, parent_subproject_id, name)
);

CREATE INDEX idx_subprojects_project ON subprojects(project_id);
CREATE INDEX idx_subprojects_parent ON subprojects(parent_subproject_id);
CREATE INDEX idx_subprojects_order ON subprojects(project_id, parent_subproject_id, order_index);

-- tasks テーブル作成
CREATE TABLE tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id INTEGER NOT NULL,
    subproject_id INTEGER DEFAULT NULL,
    name TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL DEFAULT 'UNSET',
    order_index INTEGER NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
    FOREIGN KEY (subproject_id) REFERENCES subprojects(id) ON DELETE CASCADE,
    UNIQUE(project_id, subproject_id, name),
    CHECK(status IN ('UNSET', 'NOT_STARTED', 'IN_PROGRESS', 'DONE'))
);

CREATE INDEX idx_tasks_project ON tasks(project_id);
CREATE INDEX idx_tasks_subproject ON tasks(subproject_id);
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_order ON tasks(project_id, subproject_id, order_index);

-- subtasks テーブル作成
CREATE TABLE subtasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL DEFAULT 'UNSET',
    order_index INTEGER NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
    UNIQUE(task_id, name),
    CHECK(status IN ('UNSET', 'NOT_STARTED', 'IN_PROGRESS', 'DONE'))
);

CREATE INDEX idx_subtasks_task ON subtasks(task_id);
CREATE INDEX idx_subtasks_status ON subtasks(status);
CREATE INDEX idx_subtasks_order ON subtasks(task_id, order_index);

-- task_dependencies テーブル作成
CREATE TABLE task_dependencies (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    predecessor_id INTEGER NOT NULL,
    successor_id INTEGER NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (predecessor_id) REFERENCES tasks(id) ON DELETE CASCADE,
    FOREIGN KEY (successor_id) REFERENCES tasks(id) ON DELETE CASCADE,
    UNIQUE(predecessor_id, successor_id),
    CHECK(predecessor_id != successor_id)
);

CREATE INDEX idx_task_deps_predecessor ON task_dependencies(predecessor_id);
CREATE INDEX idx_task_deps_successor ON task_dependencies(successor_id);

-- subtask_dependencies テーブル作成
CREATE TABLE subtask_dependencies (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    predecessor_id INTEGER NOT NULL,
    successor_id INTEGER NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (predecessor_id) REFERENCES subtasks(id) ON DELETE CASCADE,
    FOREIGN KEY (successor_id) REFERENCES subtasks(id) ON DELETE CASCADE,
    UNIQUE(predecessor_id, successor_id),
    CHECK(predecessor_id != successor_id)
);

CREATE INDEX idx_subtask_deps_predecessor ON subtask_dependencies(predecessor_id);
CREATE INDEX idx_subtask_deps_successor ON subtask_dependencies(successor_id);

-- templates テーブル作成
CREATE TABLE templates (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    base_type TEXT NOT NULL,
    base_id INTEGER NOT NULL,
    include_tasks BOOLEAN NOT NULL DEFAULT 1,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    CHECK(base_type IN ('project', 'subproject', 'task'))
);

CREATE INDEX idx_templates_name ON templates(name);

-- template_nodes テーブル作成
CREATE TABLE template_nodes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    template_id INTEGER NOT NULL,
    node_type TEXT NOT NULL,
    original_id INTEGER NOT NULL,
    parent_original_id INTEGER DEFAULT NULL,
    name TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL,
    order_index INTEGER NOT NULL,
    FOREIGN KEY (template_id) REFERENCES templates(id) ON DELETE CASCADE,
    CHECK(node_type IN ('project', 'subproject', 'task', 'subtask')),
    CHECK(status IN ('UNSET', 'NOT_STARTED', 'IN_PROGRESS', 'DONE'))
);

CREATE INDEX idx_template_nodes_template ON template_nodes(template_id);
CREATE INDEX idx_template_nodes_original ON template_nodes(template_id, original_id);
```

---

## 5. DB制約とアプリケーション制約の責務分離

### 5.1 DB制約（SQLiteで強制）

- 外部キー制約（参照整合性）
- UNIQUE制約（名前の重複禁止）
- CHECK制約（ステータス値の妥当性）
- NOT NULL制約（必須カラム）
- 自己参照禁止（依存関係）

### 5.2 アプリケーション制約（Pythonコードで強制）

- DAG制約（循環検出）
- レイヤ跨ぎ依存の禁止
- 同一Project/Task内の依存関係チェック
- DONE遷移条件チェック
- 子ノード存在時の削除禁止
- テンプレート外部参照チェック

**理由**:
- DAG検証は再帰的探索が必要でSQLでは困難
- 階層制約は複数テーブル横断のため、アプリケーション層が適切
- ステータス遷移ロジックはビジネスルールのため、柔軟性を保つ

---

## 6. インデックス戦略

### 6.1 主要なクエリパターン

**Project一覧取得（order順）**:
```sql
SELECT * FROM projects ORDER BY order_index;
-- 使用インデックス: idx_projects_order
```

**SubProject一覧取得（Project配下、order順）**:
```sql
SELECT * FROM subprojects
WHERE project_id = ? AND parent_subproject_id IS NULL
ORDER BY order_index;
-- 使用インデックス: idx_subprojects_order
```

**Task一覧取得（SubProject配下、order順）**:
```sql
SELECT * FROM tasks
WHERE project_id = ? AND subproject_id = ?
ORDER BY order_index;
-- 使用インデックス: idx_tasks_order
```

**依存関係取得（先行・後続）**:
```sql
-- 先行タスク取得
SELECT t.* FROM tasks t
JOIN task_dependencies d ON t.id = d.predecessor_id
WHERE d.successor_id = ?;
-- 使用インデックス: idx_task_deps_successor

-- 後続タスク取得
SELECT t.* FROM tasks t
JOIN task_dependencies d ON t.id = d.successor_id
WHERE d.predecessor_id = ?;
-- 使用インデックス: idx_task_deps_predecessor
```

**ステータス検索**:
```sql
SELECT * FROM tasks WHERE status = 'IN_PROGRESS';
-- 使用インデックス: idx_tasks_status
```

---

## 7. トランザクション方針

### 7.1 基本方針

- すべての書き込み操作はトランザクション内で実行
- 読み込みのみの操作はトランザクション不要
- 複数テーブルにまたがる操作は必ずトランザクションで保護

### 7.2 トランザクション例

**ノード削除（依存関係の橋渡し）**:
```python
with db.transaction():
    # 1. 削除対象の先行・後続を取得
    predecessors = get_predecessors(node_id)
    successors = get_successors(node_id)

    # 2. 依存関係を削除（CASCADE）
    delete_dependencies(node_id)

    # 3. 橋渡し再接続
    for pred in predecessors:
        for succ in successors:
            create_dependency(pred, succ)

    # 4. ノード削除
    delete_node(node_id)
```

**テンプレート適用**:
```python
with db.transaction():
    # 1. テンプレートノード取得
    nodes = get_template_nodes(template_id)

    # 2. 新IDマッピング作成
    id_map = {}
    for node in nodes:
        new_id = create_node_from_template(node)
        id_map[node.original_id] = new_id

    # 3. 依存関係再構築
    for dep in get_template_dependencies(template_id):
        create_dependency(
            id_map[dep.predecessor_original_id],
            id_map[dep.successor_original_id]
        )
```

---

## 8. マイグレーション方針

### 8.1 スキーマ変更時の手順

1. `schema_version`テーブルで現在のバージョン確認
2. 必要なマイグレーションSQLを順次実行
3. `schema_version`テーブルを更新

### 8.2 マイグレーション例（将来）

**例: カラム追加（v1 → v2）**:
```sql
-- バージョンチェック
SELECT version FROM schema_version;

-- マイグレーション実行
ALTER TABLE tasks ADD COLUMN priority INTEGER DEFAULT 0;

-- バージョン更新
INSERT INTO schema_version (version) VALUES (2);
```

---

## 9. 補足事項

### 9.1 テンプレート依存関係の保存

テンプレート内の依存関係は、`template_nodes`テーブルに加えて別途保存が必要です。
以下のテーブル追加を検討してください:

```sql
CREATE TABLE template_dependencies (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    template_id INTEGER NOT NULL,
    predecessor_original_id INTEGER NOT NULL,
    successor_original_id INTEGER NOT NULL,
    FOREIGN KEY (template_id) REFERENCES templates(id) ON DELETE CASCADE
);

CREATE INDEX idx_template_deps_template ON template_dependencies(template_id);
```

**注意**: 上記テーブルは本設計書には含めていませんが、Phase 3（テンプレート実装）で必要になります。

---

## 10. 確認事項

本設計書について、以下の点を確認してください:

### ✅ 確認項目

1. **テーブル構造**: 仕様を満たしているか
2. **制約**: DB制約とアプリケーション制約の分離が適切か
3. **インデックス**: パフォーマンス要件を満たすか
4. **外部キー**: CASCADE設定が適切か
5. **テンプレート設計**: スナップショット方式の実装が可能か
6. **拡張性**: SubProject入れ子対応の余地があるか

### ❓ 議論が必要な点

1. **テンプレート依存関係テーブル**: 今すぐ追加するか、Phase 3で追加するか
2. **order_index の初期値**: 0始まりか1始まりか
3. **タイムスタンプ**: UTC固定か、ローカルタイムゾーンか
4. **論理削除**: 物理削除のみか、論理削除（deleted_atカラム）も必要か

---

## 11. 次のステップ

本DB設計書を確認いただき、問題なければ以下に進みます:

1. **Phase 0 実装開始**: DB初期化スクリプト作成
2. **マイグレーション管理**: スキーマバージョン管理の実装
3. **基本CRUD実装**: Python + sqlite3 によるDB操作層

ChatGPT側でレビューいただき、修正・追加があれば反映します。

---

（以上）
