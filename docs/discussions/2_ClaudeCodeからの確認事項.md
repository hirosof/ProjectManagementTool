# Claude Code からの確認・議論事項

**作成日**: 2026-01-16
**対象仕様書**: `1_プロジェクト管理ツール_ClaudeCode仕様書.md`

---

## 確認・議論したい点

### 🔴 **優先度：高（実装前に決めるべき事項）**

#### 1. **プログラミング言語・フレームワークの選定**

仕様書には技術スタックが明記されていません。

**言語候補:**
- Python
- Rust
- Go
- Node.js

**TUIライブラリ（言語別）:**
- Python: `rich`, `textual`, `urwid`
- Rust: `ratatui`, `cursive`
- Go: `tview`, `bubbletea`

**SQLiteドライバ:**
- 標準ライブラリか、ORMか

**質問:**
- 言語の希望はありますか？
- あるいは、Claude Code から提案してもよろしいですか？

---

#### 2. **「表示順はユーザーが手動制御可能」の実装方式**

**方式A: `order`カラム（整数値管理）**
- 値: 1, 2, 3, 4...
- メリット: シンプル、理解しやすい
- デメリット: 並び替え時に大量UPDATE発生の可能性

**方式B: `position`カラム（浮動小数点管理）**
- 値: 1.0, 2.0, 2.5（間に挿入）, 3.0...
- メリット: 並び替えコストが低い
- デメリット: 精度限界がある（大量ノードで問題の可能性）

**方式C: 連結リスト方式**
- `next_id`で次のノードを参照
- メリット: 並び替えは最小コスト
- デメリット: クエリが複雑、デバッグしづらい

**Claude Code の推奨:**
- **方式A**を推奨（SQLiteの性能で問題なし、コードがシンプル）

**質問:**
- どの方式を採用しますか？

---

#### 3. **SubProjectの「将来入れ子拡張余地あり」の設計**

現状は「Project → SubProject → Task」の3階層ですが、「将来入れ子拡張」とは:

**パターンA: SubProject の無限階層化**
- SubProject → SubProject → SubProject → ...

**パターンB: SubProject内に「フォルダ」概念を追加**
- 階層構造をさらに拡張

初期実装では入れ子なしでも、**DB設計**で考慮が必要:
- `parent_subproject_id`カラムを用意するか
- テーブル構造を再帰的にするか

**質問:**
- 初期フェーズで入れ子は実装しなくても、DB設計で将来対応できるようにしておく必要がありますか？
- どちらのパターンを想定していますか？

---

### 🟡 **優先度：中（設計の明確化）**

#### 4. **「同一階層内で名前の重複は禁止」のスコープ**

**Claude Code の理解:**
- Project名は全体でユニーク
- SubProject名はProject内でユニーク
- Task名はProject（またはSubProject）内でユニーク
- SubTask名はTask内でユニーク

**質問:**
- 上記の理解で正しいですか？

---

#### 5. **テンプレート適用時の「外部参照は存在しない前提」の意味**

**「外部参照」の解釈:**
- テンプレート外のTaskへの依存関係を指すのか
- それとも、テンプレート内で完結していることを前提とするのか

**質問:**
- テンプレート保存時に外部依存をチェック/除外する処理が必要ですか？
- テンプレート保存時に外部依存が存在した場合はエラーにしますか？それとも警告のみ？

---

#### 6. **「doctor/check による整合性検査」の範囲**

**検査項目案:**
- DAG制約（循環検出）
- 依存関係の階層違反（レイヤ跨ぎ依存）
- 孤立ノード（親が存在しない）
- ステータスの矛盾（親がDONEだが子が未完了、など）
- 並び順の重複・欠番
- 依存関係の参照先が存在しない（孤立参照）

**質問:**
- これらすべてをチェックしますか？
- 他に必要なチェック項目はありますか？
- 検査結果はレポート形式？それとも修復オプション付き？

---

#### 7. **UNSET の使用シーン**

**Claude Code の理解:**
- `UNSET`はテンプレート適用時の初期状態として使用
- 通常運用でユーザーが手動で`UNSET`に変更することはない

**質問:**
- `UNSET`は「テンプレート専用の初期状態」という理解で正しいですか？
- `UNSET` → `NOT_STARTED`への遷移ルールはありますか？（自動/手動）
- 通常運用で`UNSET`に戻す操作は許可しますか？

---

### 🟢 **優先度：低（実装中に調整可能）**

#### 8. **TUIの操作イメージ**

**検討事項:**
- **ナビゲーション方式**: ツリー表示？リスト表示？
- **操作方法**: キーボードのみ？矢印キー + Enter？vim風？
- **画面構成**: 単一ペイン？分割ペイン（ツリー + 詳細）？

**質問:**
- 参考にしたいTUIアプリやイメージはありますか？
  - 例: `lazygit`, `k9s`, `htop`, `ranger`など

---

#### 9. **破壊的操作のプレビュー（dry-run）の粒度**

**プレビューが必要そうな操作:**
- ノード削除時の依存関係の橋渡しプレビュー
- テンプレート適用時の構造プレビュー
- ステータス一括変更時のプレビュー
- 子ノードを含む親ノードの削除

**質問:**
- すべての破壊的操作でプレビューが必要ですか？
- プレビュー形式はテキストベース？差分表示？

---

## 気づいた点・提案

### ✅ **良い設計だと思う点**

- DAG制約による循環禁止が明確
- ステータス管理がシンプル（DONE遷移のみ制御）
- テンプレートがスナップショット方式で独立性が高い
- 非採用事項を明示している（判断の透明性）
- 「AIによる推測・自動補完を極力排除」という方針が明確

---

### 💡 **検討を推奨する点**

#### A. **Task/SubTaskの削除操作の粒度**

仕様では「削除時に橋渡し再接続」とありますが:

**検討事項:**
- SubTaskが存在するTaskを削除する場合: SubTaskも連鎖削除？確認が必要？
- Project削除: 配下の全SubProject/Task/SubTaskを連鎖削除？
- テンプレートとして保存されているノードの削除は禁止？

**提案:**
- 「子が存在する場合は削除不可（または強制削除フラグ）」というルールを追加すべきか？
- 削除前に影響範囲を表示する？

---

#### B. **依存関係の表現方法**

**方式1: 2つのテーブル**
- `task_dependencies`
- `subtask_dependencies`
- メリット: クエリがシンプル
- デメリット: コードの重複

**方式2: 単一テーブル + `node_type`カラム**
- `dependencies` (node_type: 'task' | 'subtask')
- メリット: 拡張性が高い
- デメリット: クエリが若干複雑

**提案:**
- 方式1の方がクエリがシンプルになりますが、方式2の方が拡張性は高いです。
- どちらを優先しますか？

---

#### C. **エラーハンドリングとユーザーへのフィードバック**

TUIで操作が失敗した場合:

**検討事項:**
- エラーメッセージの表示方法（モーダル？ステータスバー？ログファイル？）
- 操作のUNDO機能は必要か？
- エラーログの保存先は？

**質問:**
- UNDO機能は初期フェーズで必要ですか？
- エラー時のロールバック方針は？（トランザクション管理）

---

#### D. **パフォーマンスの想定規模**

**質問:**
- 想定するノード数の規模は？
  - Project: 10個？100個？
  - Task: 1プロジェクトあたり100個？1000個？
- 依存関係の数の想定は？
- パフォーマンス要件は？（レスポンス時間の目安）

---

#### E. **データのバックアップ・エクスポート**

**質問:**
- SQLiteファイルのバックアップ機能は必要ですか？
- エクスポート/インポート機能（JSON, YAML等）は初期フェーズで必要ですか？
- バージョン管理（Git等）との連携は考慮しますか？

---

## 次のステップ

上記の質問・確認事項について、優先度の高いものから順に議論できればと思います。

**特に重要な項目（🔴 優先度：高）:**

1. **言語・フレームワーク選定**
2. **並び順の実装方式**
3. **SubProjectの入れ子対応のDB設計方針**

これらが決まれば、DB設計とコア機能の実装に入れます。

---

## 補足: 実装フェーズの提案

仕様書では「段階的（フェーズ分割）を許容」とありますが、以下のようなフェーズ分けを提案します:

**Phase 0: 基盤構築**
- プロジェクトセットアップ
- DB設計・マイグレーション
- 基本的なCRUD操作（CLI版でも可）

**Phase 1: コア機能**
- 階層構造の作成・削除
- 依存関係の設定・検証（DAG制約）
- ステータス管理
- 並び順制御

**Phase 2: TUI実装**
- 基本的なナビゲーション
- ノード表示・編集
- 依存関係の視覚化

**Phase 3: 高度な機能**
- テンプレート機能
- doctor/check機能
- dry-runプレビュー

**Phase 4: 改善・最適化**
- パフォーマンス改善
- エラーハンドリング強化
- ユーザビリティ向上

この分け方でよろしいですか？それとも別の分け方を希望されますか？
